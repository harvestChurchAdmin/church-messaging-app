<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harvest Church Messenger</title>
    <!-- Google Fonts for consistency with login page -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/style.css"> <!-- Link to the shared stylesheet -->
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body class="app-body">
    <!-- Header for Logo and User Info -->
    <header class="app-header">
        <img id="appLogo" src="{{APP_LOGO_URL}}" alt="Application Logo" class="logo">
        <div class="user-info-container">
            <h2 id="userNameDisplay" class="user-info"></h2>
            <h3 id="userEmailDisplay" class="user-info"></h3>
            <button id="logoutButton" class="logout-button">Logout</button>
        </div>
    </header>

    <div class="container">
        <div class="left-column">
            <!-- SMS Message Section -->
            <div class="card sms-message-section">
                <h1>Send SMS Message</h1>
                <textarea id="message" placeholder="Enter your message" maxlength="160"></textarea>
                <div id="charCount" class="char-count">160 characters remaining</div>
                <button id="sendSms">Send SMS</button>
            </div>

            <!-- People List Section -->
            <div class="card people-list-section">
                <h2>Filtered People</h2>
                <!-- NEW: Search input for people list -->
                <input type="text" id="peopleSearchInput" placeholder="Search by name..." class="text-input" style="margin-bottom: 15px;">
                <div class="selection-controls" style="display: none;">
                    <button id="selectAllVisible">Select All Visible</button>
                    <button id="clearAllSelected">Clear All</button>
                </div>
                <div id="peopleList" class="people-list">
                    <p>Apply a tag filter to see people.</p>
                </div>
                <div id="peopleLoadingIndicator" class="loading-indicator" style="display: none;">
                    <div class="spinner"></div>
                    Loading people...
                </div>
            </div>
        </div>

        <div class="right-column">
            <!-- Tag Filter Section -->
            <div class="card tag-filter-section">
                <h1>Filter People by Tags</h1>
                <!-- NEW: Search input for tags -->
                <input type="text" id="tagSearchInput" placeholder="Search by tag name..." class="text-input" style="margin-bottom: 15px;">
                <!-- Moved tagLoadingIndicator inside tagFilter, but before tag-content-wrapper -->
                <div id="tagFilter">
                    <div id="tagLoadingIndicator" class="loading-indicator">
                        <div class="spinner"></div>
                        Loading tags...
                    </div>
                    <!-- This div will now be the scrollable container for tags -->
                    <div class="tag-content-wrapper" style="display: none;"></div>
                </div>
                <!-- Button and cooldown display are now outside the scrollable tag-filter-container -->
                <button id="applyFilterButton">Apply Tag Filter</button>
                <div id="apiCooldownWrapper" style="margin-top: 10px; display: flex; flex-direction: column; align-items: center;">
                    <span id="apiCooldownDisplay" style="color: #d9534f; font-weight: bold;"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- SMS History Section -->
    <div style="margin: 20px auto; max-width: 1200px;">
        <div class="card sms-history-section">
            <h1>SMS History</h1>
            <!-- NEW: Color Legend -->
            <div class="legend" style="margin-bottom: 15px;">
                <strong>Status Legend:</strong>
                <span class="legend-item"><span class="status-delivered" style="margin-right: 5px;">✓</span> Delivered</span> |
                <span class="legend-item"><span class="status-pending" style="margin-right: 5px;">✓</span> Pending</span> |
                <span class="legend-item"><span class="status-failed" style="margin-right: 5px;">✓</span> Failed</span>
            </div>
            <!-- NEW: Per-page dropdown -->
            <div style="margin-bottom: 15px;">
                <label for="perPageSelect">Records per page: </label>
                <select id="perPageSelect" class="text-input" style="width: 120px; margin-left: 10px; padding: 10px;">
                    <option value="25">25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>
            <!-- NEW: Search input for SMS history -->
            <input type="text" id="smsSearchInput" placeholder="Search SMS..." class="text-input" style="margin-bottom: 15px;">
            <div class="sms-history-controls">
                <button id="refreshSmsHistory">Refresh History</button>
            </div>
            <div class="sms-history-container">
                <table id="smsHistoryTable">
                    <thead>
                        <tr>
                            <th>Recipient</th>
                            <th>Sender</th>
                            <th>Message</th>
                            <th>Status</th>
                            <th>Sent At</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td colspan="5">Loading SMS history...</td></tr>
                    </tbody>
                </table>
                <div id="smsHistoryLoading" class="loading-indicator" style="display: none;">
                    <div class="spinner"></div>
                    Loading SMS history...
                </div>
            </div>
            <!-- NEW: Pagination Controls -->
            <div class="pagination-controls" style="margin-top: 15px; display: flex; gap: 10px; align-items: center; justify-content: center;">
                <button id="prevPage" style="padding: 8px 15px;">Previous</button>
                <span id="pageInfo"></span>
                <button id="nextPage" style="padding: 8px 15px;">Next</button>
            </div>
        </div>
    </div>

    <!-- Message box for user feedback -->
    <div id="messageBox" class="message-box"></div>

    <script>
        // Store selected people's IDs and their full data for SMS sending
        let selectedPeopleForSms = new Map();
        let lastAppliedTagIds = [];

        // Global variable to store logged-in user's details
        let currentUser = null;

        // Store all people fetched after a tag filter (for search within)
        let peopleFilteredByTags = [];

        // API Cooldown variables
        let isApiCoolingDown = false;
        let apiCooldownEndTime = 0;
        let apiCooldownInterval = null;

        // Pagination variables
        let currentPage = 1;
        let perPage = 25;
        let totalRecords = 0;

        document.addEventListener('DOMContentLoaded', async () => {
            const sendSmsButton = document.getElementById('sendSms');
            const messageInput = document.getElementById('message');
            const charCountDisplay = document.getElementById('charCount');
            const peopleListDiv = document.getElementById('peopleList');
            const tagFilterDiv = document.getElementById('tagFilter');
            const applyFilterButton = document.getElementById('applyFilterButton');
            const clearAllSelectedButton = document.getElementById('clearAllSelected');
            const selectAllVisibleButton = document.getElementById('selectAllVisible');
            const smsHistoryTableBody = document.querySelector('#smsHistoryTable tbody');
            const refreshSmsHistoryButton = document.getElementById('refreshSmsHistory');
            const tagLoadingIndicator = document.getElementById('tagLoadingIndicator');
            const tagContentWrapper = document.querySelector('#tagFilter .tag-content-wrapper');
            const peopleLoadingIndicator = document.getElementById('peopleLoadingIndicator');
            const selectionControls = document.querySelector('.selection-controls');
            const smsHistoryLoading = document.getElementById('smsHistoryLoading');
            const peopleSearchInput = document.getElementById('peopleSearchInput');
            const apiCooldownDisplay = document.getElementById('apiCooldownDisplay');
            const tagSearchInput = document.getElementById('tagSearchInput');
            const perPageSelect = document.getElementById('perPageSelect');
            const prevPageButton = document.getElementById('prevPage');
            const nextPageButton = document.getElementById('nextPage');
            const pageInfo = document.getElementById('pageInfo');
            const smsSearchInput = document.getElementById('smsSearchInput');

            const MAX_SMS_CHARS = 160;

            function showMessageBox(message, type = 'info', duration = 3000) {
                const messageBox = document.getElementById('messageBox');
                messageBox.textContent = message;
                messageBox.className = `message-box ${type} show`;
                setTimeout(() => {
                    messageBox.classList.remove('show');
                }, duration);
            }

            async function fetchCurrentUser() {
                try {
                    const response = await fetch('/user');
                    if (!response.ok) {
                        if (response.status === 401 || response.status === 403) {
                            window.location.href = '/login';
                            return;
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    currentUser = await response.json();
                    if (currentUser && currentUser.displayName && currentUser.email) {
                        document.getElementById('userNameDisplay').textContent = `Welcome, ${currentUser.displayName}`;
                        document.getElementById('userEmailDisplay').textContent = currentUser.email;
                    } else {
                        console.warn('Current user data is incomplete or not available.');
                        document.getElementById('userNameDisplay').textContent = 'Welcome!';
                        document.getElementById('userEmailDisplay').textContent = 'Email not found.';
                    }
                } catch (error) {
                    console.error('Error fetching current user:', error);
                    showMessageBox('Failed to fetch user data. Please refresh.', 'error');
                }
            }

            const logoutButton = document.getElementById('logoutButton');
            if (logoutButton) {
                logoutButton.addEventListener('click', async () => {
                    try {
                        const response = await fetch('/auth/logout');
                        if (response.ok) {
                            window.location.href = '/login';
                        } else {
                            showMessageBox('Logout failed.', 'error');
                        }
                    } catch (error) {
                        console.error('Error during logout:', error);
                        showMessageBox('Error during logout.', 'error');
                    }
                });
            }

            function formatTimestamp(timestamp) {
                if (!timestamp) return 'N/A';
                const date = new Date(timestamp);
                const options = {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true
                };
                return date.toLocaleString('en-US', options);
            }

            async function fetchSmsHistory(page = 1) {
                smsHistoryTableBody.innerHTML = '<tr><td colspan="5"></td></tr>';
                smsHistoryLoading.style.display = 'flex';
                try {
                    const response = await fetch(`/api/sms-history?page=${page}&perPage=${perPage}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    totalRecords = data.total || data.length; // Adjust based on API response structure
                    displaySmsHistory(data.history || data, page);
                } catch (error) {
                    console.error('Error fetching SMS history:', error);
                    showMessageBox('Failed to load SMS history.', 'error');
                    smsHistoryTableBody.innerHTML = '<tr><td colspan="5" class="error">Failed to load SMS history.</td></tr>';
                } finally {
                    smsHistoryLoading.style.display = 'none';
                }
            }

            function displaySmsHistory(history, page) {
                smsHistoryTableBody.innerHTML = '';
                const searchTerm = smsSearchInput.value.toLowerCase().trim();
                let filteredHistory = Array.isArray(history) ? history : [];
                if (searchTerm) {
                    filteredHistory = filteredHistory.filter(record => {
                        return (record.recipientName || record.toPhoneNumber || '').toLowerCase().includes(searchTerm) ||
                               (record.senderName || record.senderUserId || '').toLowerCase().includes(searchTerm) ||
                               (record.messageBody || '').toLowerCase().includes(searchTerm) ||
                               (record.status || '').toLowerCase().includes(searchTerm);
                    });
                    totalRecords = filteredHistory.length; // Update total for filtered results
                } else {
                    totalRecords = Array.isArray(history) ? history.length : 0;
                }
                const start = (page - 1) * perPage;
                const end = start + perPage;
                const paginatedHistory = filteredHistory.slice(start, end);

                if (paginatedHistory.length === 0) {
                    smsHistoryTableBody.innerHTML = '<tr><td colspan="5">No SMS records found.</td></tr>';
                    return;
                }

                paginatedHistory.forEach(record => {
                    const row = smsHistoryTableBody.insertRow();
                    row.insertCell().textContent = record.recipientName || record.toPhoneNumber;
                    row.insertCell().textContent = record.senderName || record.senderUserId;
                    row.insertCell().textContent = record.messageBody;
                    row.insertCell().textContent = record.status;
                    row.insertCell().textContent = formatTimestamp(record.createdAt);

                    if (record.status === 'delivered') {
                        row.classList.add('status-delivered');
                    } else if (record.status === 'failed' || record.status === 'undelivered') {
                        row.classList.add('status-failed');
                    } else if (record.status === 'queued' || record.status === 'sending' || record.status === 'sent') {
                        row.classList.add('status-pending');
                    }
                });

                updatePagination();
            }

            function updatePagination() {
                const totalPages = Math.ceil(totalRecords / perPage);
                pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
                prevPageButton.disabled = currentPage === 1;
                nextPageButton.disabled = currentPage === totalPages;
            }

            let allPeopleFromTags = [];

            function getPhoneNumber(person) {
                const phoneEntries = person.details && person.details['1413026988'];
                if (Array.isArray(phoneEntries)) {
                    const mobileEntry = phoneEntries.find(entry => entry && entry.phone_type === 'mobile' && entry.phone_number);
                    if (mobileEntry) return mobileEntry.phone_number;
                    if (phoneEntries.length > 0 && phoneEntries[0].phone_number) return phoneEntries[0].phone_number;
                }
                return null;
            }

            function renderPeopleList(peopleToDisplay) {
                peopleListDiv.innerHTML = '';
                if (peopleToDisplay.length === 0) {
                    peopleListDiv.innerHTML = '<p>No people match your search or tag filter.</p>';
                    selectionControls.style.display = 'none';
                    return;
                }
                selectionControls.style.display = 'flex';
                peopleToDisplay.forEach(person => {
                    const personDiv = document.createElement('div');
                    personDiv.className = 'person-item';
                    const fullName = `${person.first_name || ''} ${person.last_name || ''}`.trim();
                    const phoneNumber = getPhoneNumber(person);
                    const isSelected = selectedPeopleForSms.has(person.id);
                    personDiv.innerHTML = `
                        <input type="checkbox" id="person-${person.id}" value="${person.id}" ${phoneNumber ? '' : 'disabled'} ${isSelected ? 'checked' : ''}>
                        <label for="person-${person.id}">${fullName} ${phoneNumber ? `(${phoneNumber})` : ' (No Mobile Number)'}</label>
                    `;
                    const checkbox = personDiv.querySelector(`input[type="checkbox"]`);
                    if (!checkbox.disabled) {
                        checkbox.addEventListener('change', (event) => {
                            if (event.target.checked) {
                                selectedPeopleForSms.set(person.id, { id: person.id, name: fullName, phoneNumber });
                            } else {
                                selectedPeopleForSms.delete(person.id);
                            }
                        });
                    }
                    peopleListDiv.appendChild(personDiv);
                });
            }

            function displayPeople(people) {
                allPeopleFromTags = people;
                filterPeopleBySearchTerm();
            }

            function filterPeopleBySearchTerm() {
                const searchTerm = peopleSearchInput.value.toLowerCase().trim();
                let peopleToDisplay = allPeopleFromTags;
                if (searchTerm) {
                    peopleToDisplay = allPeopleFromTags.filter(person => {
                        const fullName = `${person.first_name || ''} ${person.last_name || ''}`.trim().toLowerCase();
                        const phoneNumber = getPhoneNumber(person);
                        return fullName.includes(searchTerm) || (phoneNumber && phoneNumber.includes(searchTerm));
                    });
                }
                renderPeopleList(peopleToDisplay);
            }

            function startApiCooldown(options = {}) {
                const { baseDurationMs = 5000, errorDurationMs = 30000, message = 'Waiting for server', isError = false, peopleCount = 0 } = options;
                let durationMs = isError ? errorDurationMs : baseDurationMs;
                if (!isError && peopleCount > 0) {
                    const COOLDOWN_PER_PERSON_MS = 100;
                    const MIN_COOLDOWN_FOR_PEOPLE = 5000;
                    let calculatedDynamicDuration = peopleCount * COOLDOWN_PER_PERSON_MS;
                    durationMs = Math.max(MIN_COOLDOWN_FOR_PEOPLE, calculatedDynamicDuration);
                } else if (!isError && peopleCount === 0) {
                    durationMs = 5000;
                }
                const MAX_DYNAMIC_COOLDOWN = 90000;
                durationMs = Math.min(durationMs, MAX_DYNAMIC_COOLDOWN);
                if (apiCooldownInterval) clearInterval(apiCooldownInterval);
                isApiCoolingDown = true;
                applyFilterButton.disabled = true;
                applyFilterButton.style.opacity = '0.7';
                applyFilterButton.style.cursor = 'not-allowed';
                apiCooldownEndTime = Date.now() + durationMs;
                apiCooldownDisplay.textContent = `${message} (${Math.ceil(durationMs / 1000)}s)...`;
                apiCooldownInterval = setInterval(() => {
                    const timeLeft = Math.ceil((apiCooldownEndTime - Date.now()) / 1000);
                    if (timeLeft <= 0) {
                        clearInterval(apiCooldownInterval);
                        isApiCoolingDown = false;
                        applyFilterButton.disabled = false;
                        applyFilterButton.style.opacity = '1';
                        applyFilterButton.style.cursor = 'pointer';
                        apiCooldownDisplay.textContent = '';
                        showMessageBox('Server is ready. You can filter again.', 'info', 2000);
                    } else {
                        apiCooldownDisplay.textContent = `${message} (${timeLeft}s)...`;
                    }
                }, 1000);
            }

            async function fetchPeople(tagIds = []) {
                if (isApiCoolingDown) {
                    showMessageBox(`API is currently on cooldown. Please wait before filtering again.`, 'warning');
                    return;
                }
                peopleListDiv.innerHTML = '<p>Loading people...</p>';
                peopleLoadingIndicator.style.display = 'flex';
                selectionControls.style.display = 'none';
                peopleSearchInput.value = '';
                allPeopleFromTags = [];
                applyFilterButton.disabled = true;
                applyFilterButton.style.opacity = '0.7';
                applyFilterButton.style.cursor = 'not-allowed';
                try {
                    const queryParams = tagIds.length > 0 ? `?${tagIds.map(id => `tag_id=${id}`).join('&')}` : '';
                    const response = await fetch(`/api/people${queryParams}`);
                    if (!response.ok) {
                        if (response.status === 429) {
                            console.error('Breeze API Rate Limit Exceeded (429)');
                            showMessageBox('Too many requests to Breeze API. Please wait a moment.', 'error', 5000);
                            startApiCooldown({ errorDurationMs: 30000, message: 'Rate limit hit. Waiting for server', isError: true });
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const people = await response.json();
                    displayPeople(people);
                    lastAppliedTagIds = tagIds;
                    startApiCooldown({ peopleCount: people.length, message: 'Processing complete. Waiting', baseDurationMs: 5000 });
                } catch (error) {
                    console.error('Error fetching people:', error);
                    peopleListDiv.innerHTML = '<p class="error">Failed to load people. Please try again.</p>';
                    selectionControls.style.display = 'none';
                    if (!isApiCoolingDown) {
                        applyFilterButton.disabled = false;
                        applyFilterButton.style.opacity = '1';
                        applyFilterButton.style.cursor = 'pointer';
                    }
                } finally {
                    peopleLoadingIndicator.style.display = 'none';
                }
            }

            function setNodeCheckedState(node, checked) {
                node.checked = checked;
                const selfCheckbox = document.getElementById(`${node.type}-${node.id}`);
                if (selfCheckbox) selfCheckbox.checked = checked;
                if (node.type === 'folder') {
                    if (node.tags) node.tags.forEach(tag => { tag.checked = checked; const checkbox = document.getElementById(`tag-${tag.id}`); if (checkbox) checkbox.checked = checked; });
                    if (node.children) node.children.forEach(childNode => setNodeCheckedState(childNode, checked));
                }
            }

            function displayTags(tagTree, parentElement) {
                tagContentWrapper.innerHTML = '';
                tagContentWrapper.style.display = 'block';
                tagTree.forEach(node => {
                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = `tag-node ${node.type}`;
                    if (node.type === 'folder') {
                        const folderHeader = document.createElement('div');
                        folderHeader.className = 'folder-header';
                        folderHeader.innerHTML = `
                            <span class="folder-toggle ${node.expanded ? 'expanded' : ''}">▶</span>
                            <input type="checkbox" id="folder-${node.id}" value="${node.id}" ${node.checked ? 'checked' : ''}>
                            <label for="folder-${node.id}"> ${node.name}</label>
                        `;
                        nodeDiv.appendChild(folderHeader);
                        const childrenContainer = document.createElement('div');
                        childrenContainer.className = 'folder-children';
                        if (node.expanded) childrenContainer.style.display = 'block';
                        else childrenContainer.style.display = 'none';
                        nodeDiv.appendChild(childrenContainer);
                        folderHeader.querySelector('.folder-toggle').addEventListener('click', () => {
                            node.expanded = !node.expanded;
                            folderHeader.querySelector('.folder-toggle').classList.toggle('expanded', node.expanded);
                            childrenContainer.style.display = node.expanded ? 'block' : 'none';
                        });
                        folderHeader.querySelector(`input[type="checkbox"]#folder-${node.id}`).addEventListener('change', (event) => {
                            setNodeCheckedState(node, event.target.checked);
                        });
                        node.tags.forEach(tag => {
                            const tagItemDiv = document.createElement('div');
                            tagItemDiv.className = 'tag-item';
                            tagItemDiv.innerHTML = `
                                <input type="checkbox" id="tag-${tag.id}" value="${tag.id}" ${tag.checked ? 'checked' : ''}>
                                <label for="tag-${tag.id}">${tag.name}</label>
                            `;
                            childrenContainer.appendChild(tagItemDiv);
                            tagItemDiv.querySelector('input[type="checkbox"]').addEventListener('change', () => {
                                tag.checked = !tag.checked;
                            });
                        });
                        if (node.children && node.children.length > 0) displayTags(node.children, childrenContainer);
                    } else if (node.type === 'tag') {
                        const tagItemDiv = document.createElement('div');
                        tagItemDiv.className = 'tag-item';
                        tagItemDiv.innerHTML = `
                            <input type="checkbox" id="tag-${node.id}" value="${node.id}" ${node.checked ? 'checked' : ''}>
                            <label for="tag-${node.id}">${node.name}</label>
                        `;
                        nodeDiv.appendChild(tagItemDiv);
                        tagItemDiv.querySelector('input[type="checkbox"]').addEventListener('change', () => {
                            node.checked = !node.checked;
                        });
                    }
                    parentElement.appendChild(nodeDiv);
                });
            }

            let currentTagTree = [];
            async function fetchTags() {
                tagLoadingIndicator.style.display = 'flex';
                tagContentWrapper.style.display = 'none';
                try {
                    const response = await fetch('/api/tags');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    currentTagTree = await response.json();
                    displayTags(currentTagTree, tagContentWrapper);
                } catch (error) {
                    console.error('Error fetching tags:', error);
                    tagContentWrapper.innerHTML = '<p class="error">Failed to load tags. Please try again.</p>';
                    tagContentWrapper.style.display = 'block';
                } finally {
                    tagLoadingIndicator.style.display = 'none';
                }
            }

            function getCheckedTagIds(nodes) {
                let checkedIds = [];
                nodes.forEach(node => {
                    if (node.type === 'tag' && node.checked) checkedIds.push(node.id);
                    else if (node.type === 'folder' && node.checked) {
                        if (node.tags) node.tags.forEach(tag => checkedIds.push(tag.id));
                        if (node.children) checkedIds = checkedIds.concat(getCheckedTagIds(node.children));
                    } else if (node.type === 'folder' && !node.checked) {
                        if (node.tags) node.tags.forEach(tag => { if (tag.checked) checkedIds.push(tag.id); });
                        if (node.children) checkedIds = checkedIds.concat(getCheckedTagIds(node.children));
                    }
                });
                return [...new Set(checkedIds)];
            }

            function debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            function updatePeopleFilter() {
                if (isApiCoolingDown) {
                    showMessageBox(`Please wait ${Math.ceil((apiCooldownEndTime - Date.now()) / 1000)}s before applying another filter.`, 'warning');
                    return;
                }
                const checkedTagIds = getCheckedTagIds(currentTagTree);
                if (checkedTagIds.length === 0) {
                    peopleListDiv.innerHTML = '<p>No tags selected. Apply a tag filter to see people.</p>';
                    selectionControls.style.display = 'none';
                    allPeopleFromTags = [];
                    peopleSearchInput.value = '';
                    return;
                }
                fetchPeople(checkedTagIds);
            }

            clearAllSelectedButton.addEventListener('click', () => {
                selectedPeopleForSms.clear();
                document.querySelectorAll('#peopleList input[type="checkbox"]').forEach(checkbox => checkbox.checked = false);
            });

            selectAllVisibleButton.addEventListener('click', () => {
                document.querySelectorAll('#peopleList .person-item input[type="checkbox"]').forEach(checkbox => {
                    const personId = checkbox.value;
                    const person = allPeopleFromTags.find(p => p.id === personId);
                    const phoneNumber = getPhoneNumber(person);
                    if (phoneNumber) {
                        checkbox.checked = true;
                        const fullName = `${person.first_name || ''} ${person.last_name || ''}`.trim();
                        selectedPeopleForSms.set(person.id, { id: person.id, name: fullName, phoneNumber });
                    } else checkbox.checked = false;
                });
            });

            sendSmsButton.addEventListener('click', async () => {
                const message = messageInput.value.trim();
                const peopleToSend = Array.from(selectedPeopleForSms.values());
                if (peopleToSend.length === 0) {
                    showMessageBox('Please select at least one person to send an SMS.', 'error');
                    return;
                }
                if (!message) {
                    showMessageBox('Please enter a message to send.', 'error');
                    return;
                }
                if (!currentUser || !currentUser.displayName) {
                    showMessageBox('Sender information not available. Please log in again.', 'error');
                    return;
                }
                try {
                    for (const person of peopleToSend) {
                        const phoneNumber = person.phoneNumber;
                        const recipientName = person.name;
                        const senderName = currentUser.displayName;
                        const response = await fetch('/api/send-sms', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ to: phoneNumber, message, recipientName, senderName })
                        });
                        const data = await response.json();
                        if (response.ok) showMessageBox(`SMS sent to ${recipientName} successfully!`, 'success');
                        else showMessageBox(`Failed to send SMS to ${recipientName}: ${data.message}`, 'error');
                    }
                    messageInput.value = '';
                    selectedPeopleForSms.clear();
                    document.querySelectorAll('#peopleList input[type="checkbox"]').forEach(checkbox => checkbox.checked = false);
                    fetchSmsHistory(currentPage);
                } catch (error) {
                    console.error('Error sending SMS:', error);
                    showMessageBox('Error sending SMS to one or more recipients.', 'error');
                }
            });

            refreshSmsHistoryButton.addEventListener('click', () => fetchSmsHistory(currentPage));
            applyFilterButton.addEventListener('click', debounce(updatePeopleFilter, 500));
            peopleSearchInput.addEventListener('input', filterPeopleBySearchTerm);
            tagSearchInput.addEventListener('input', () => {
                const filter = tagSearchInput.value.toLowerCase().trim();
                const tagItems = tagContentWrapper.querySelectorAll('.tag-item, .folder-header');
                tagItems.forEach(item => {
                    const text = item.textContent.toLowerCase();
                    const parentFolder = item.closest('.folder-children');
                    item.style.display = text.includes(filter) ? '' : 'none';
                    if (parentFolder) {
                        const parentHeader = parentFolder.previousElementSibling;
                        const visibleChildren = Array.from(parentFolder.querySelectorAll('.tag-item, .folder-header')).some(child => child.style.display !== 'none');
                        if (visibleChildren && parentHeader) {
                            parentHeader.style.display = '';
                            parentFolder.style.display = 'block';
                            parentHeader.querySelector('.folder-toggle').classList.add('expanded');
                        }
                    }
                });
            });

            perPageSelect.addEventListener('change', (e) => {
                perPage = parseInt(e.target.value);
                currentPage = 1;
                fetchSmsHistory(currentPage);
            });

            prevPageButton.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    fetchSmsHistory(currentPage);
                }
            });

            nextPageButton.addEventListener('click', () => {
                const totalPages = Math.ceil(totalRecords / perPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    fetchSmsHistory(currentPage);
                }
            });

            smsSearchInput.addEventListener('input', () => {
                currentPage = 1; // Reset to first page on new search
                fetchSmsHistory(currentPage);
            });

            messageInput.addEventListener('input', () => {
                const charsRemaining = MAX_SMS_CHARS - messageInput.value.length;
                charCountDisplay.textContent = `${charsRemaining} characters remaining`;
                charCountDisplay.style.color = charsRemaining < 0 ? 'red' : '';
            });

            messageInput.dispatchEvent(new Event('input'));

            try {
                await fetchCurrentUser();
                await fetchTags();
                await fetchSmsHistory(currentPage);
            } catch (error) {
                console.error('Error during initial page load setup:', error);
                showMessageBox('An error occurred during initial setup. Please refresh the page.', 'error', 5000);
            }
        });
    </script>
</body>
</html>