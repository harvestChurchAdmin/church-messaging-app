<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harvest Church Messenger</title>
    <!-- Google Fonts for consistency with login page -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/style.css"> <!-- Link to the shared stylesheet -->
</head>
<body class="app-body">
    <div class="container">
        <div class="left-column">
            <!-- Harvest Church Logo on Index Page -->
            <!-- Application Logo: This image tag will have its src dynamically set by server.js -->
            <img id="appLogo" src="{{APP_LOGO_URL}}" alt="Application Logo" class="logo">
            <!-- SMS Message Section - Stays at top of left column -->
            <h1>Send SMS Message</h1>
            <textarea id="message" placeholder="Enter your message"></textarea>
            <button id="sendSms">Send SMS</button>

            <!-- People List - Now in the left column, below SMS -->
            <h2 class="mt-8">Filtered People</h2> <!-- Added margin-top for spacing -->
            <div class="select-all-container">
                <input type="checkbox" id="selectAllPeopleCheckbox">
                <label for="selectAllPeopleCheckbox">Select All Visible People</label>
            </div>
            <ul id="peopleList">
                <!-- People data will be inserted here by JavaScript -->
            </ul>
        </div>

        <div class="right-column">
            <!-- Breeze Church Management People & Tag Filtering - Moved to right column -->
            <h2>Breeze Church Management Tags</h2>
            <div>
                <label>Filter by Tag:</label>
                <div id="tagFilterContainer" class="tag-filter-container">
                    <div id="tagLoadingIndicator" class="loading-indicator" style="display: none;">
                        <div class="spinner"></div>
                        Loading tags...
                    </div>
                    <!-- This div will hold the dynamically rendered tags and folders -->
                    <div class="tag-content-wrapper"></div> 
                </div>
                <button id="applyFilterButton">Apply Tag Filter</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- GLOBAL VARIABLES (within DOMContentLoaded scope) - Declare first ---
            const peopleList = document.getElementById('peopleList');
            const tagFilterContainer = document.getElementById('tagFilterContainer');
            const applyFilterButton = document.getElementById('applyFilterButton');
            const tagLoadingIndicator = document.getElementById('tagLoadingIndicator');
            const tagContentWrapper = tagFilterContainer.querySelector('.tag-content-wrapper');
            const sendSmsButton = document.getElementById('sendSms');
            const selectAllPeopleCheckbox = document.getElementById('selectAllPeopleCheckbox');
            const appLogo = document.getElementById('appLogo'); // Get the logo element

            let allTagsData = []; // Stores the full tag tree for state management
            let selectedPeopleForSms = new Map(); // Stores {personId: phoneNumber} for selected people
            let lastAppliedTagIds = []; // Stores the tag IDs from the last applied filter

            // Relying solely on server-side injection for appLogo.src


            // --- ALL FUNCTION DECLARATIONS GO HERE (after global variables, before initial calls) ---

            // Custom message box function (replaces alert)
            function showMessageBox(message, type = 'info') {
                const messageBox = document.createElement('div');
                messageBox.classList.add('message-box', type);
                messageBox.textContent = message;
                document.body.appendChild(messageBox);

                // Automatically remove after a few seconds
                setTimeout(() => {
                    messageBox.remove();
                }, 3000); // 3 seconds
            }

            /**
             * Recursively updates the 'checked' state of a tag or folder within the allTagsData structure.
             * This ensures the master data source reflects UI changes.
             * @param {string} id - The ID of the tag or folder to update.
             * @param {boolean} checked - The new checked state.
             * @param {string} type - 'tag' or 'folder'
             * @param {Array<Object>} nodes - The current level of nodes to search.
             * @returns {boolean} - True if the node was found and updated.
             */
            function updateTagCheckedState(id, checked, type, nodes) {
                nodes = nodes || allTagsData; // Ensure nodes is always an array

                for (const node of nodes) {
                    if (node.id === id && node.type === type) {
                        node.checked = checked;
                        return true; // Found and updated
                    }
                    if (node.children && node.children.length > 0) {
                        if (updateTagCheckedState(id, checked, type, node.children)) {
                            return true; // Found in children
                        }
                    }
                    if (node.tags && node.tags.length > 0 && type === 'tag') { 
                        for (const tag of node.tags) {
                            if (tag.id === id) {
                                tag.checked = checked;
                                return true; // Found and updated
                            }
                        }
                    }
                }
                return false; // Not found
            }

            /**
             * Recursively checks/unchecks all children (sub-folders and tags) of a given node.
             * @param {Object} node - The current folder node.
             * @param {boolean} checked - The checked state to apply.
             */
            function checkAllChildren(node, checked) {
                if (node.children) {
                    node.children.forEach(child => {
                        const checkbox = document.getElementById(`checkbox-${child.id}`);
                        if (checkbox) {
                            checkbox.checked = checked;
                            updateTagCheckedState(child.id, checked, 'folder');
                        }
                        checkAllChildren(child, checked); // Recursively check sub-folders
                    });
                }
                if (node.tags) {
                    node.tags.forEach(tag => {
                        const checkbox = document.getElementById(`checkbox-${tag.id}`);
                        if (checkbox) {
                            checkbox.checked = checked;
                            updateTagCheckedState(tag.id, checked, 'tag');
                        }
                    });
                }
            }

            /**
             * Recursively collects the IDs of all selected tags.
             * @param {Array<Object>} nodes - An array of folder or tag nodes.
             * @param {Array<string>} selectedIds - The array to populate with selected tag IDs.
             */
            function collectSelectedTagIds(nodes, selectedIds) {
                nodes.forEach(node => {
                    if (node.type === 'tag' && node.checked) {
                        selectedIds.push(node.id);
                    }
                    if (node.children) {
                        collectSelectedTagIds(node.children, selectedIds);
                    }
                    if (node.tags) {
                        node.tags.forEach(tag => {
                            if (tag.checked) {
                                selectedIds.push(tag.id);
                            }
                        });
                    }
                });
            }

            /**
             * Extracts the mobile phone number from a person object based on the new payload structure.
             * The phone data is expected within the 'details' object, under the field ID '1413026988',
             * which is an array of phone entries, each with 'phone_number' and 'phone_type'.
             * @param {Object} person - The person object from Breeze API.
             * @returns {string} The mobile phone number, or 'N/A' if not found.
             */
            function getMobilePhoneNumber(person) {
                // Access the 'details' object first, then the specific field ID '1413026988'.
                // Ensure 'details' exists before trying to access its properties.
                const phoneEntries = person.details && person.details['1413026988'];

                if (Array.isArray(phoneEntries)) {
                    // Find the entry that specifically has 'phone_type' as 'mobile'
                    const mobileEntry = phoneEntries.find(entry => 
                        entry && entry.phone_type === 'mobile' && entry.phone_number
                    );
                    if (mobileEntry) {
                        return mobileEntry.phone_number;
                    }
                    // If no 'mobile' type, try to return the first available number
                    // (e.g., home or work phone if mobile is not present)
                    if (phoneEntries.length > 0 && phoneEntries[0].phone_number) {
                        return phoneEntries[0].phone_number;
                    }
                }
                return 'N/A';
            }

            /**
             * Displays the list of people in the UI with checkboxes, name, and phone.
             * @param {Array<Object>} people - An array of person objects.
             */
            function displayPeople(people) {
                peopleList.innerHTML = ''; // Clear existing list
                selectedPeopleForSms.clear(); // Clear previously selected people for SMS
                selectAllPeopleCheckbox.checked = false; 
                selectAllPeopleCheckbox.disabled = true; 

                if (people.length === 0) {
                    peopleList.innerHTML = '<li>No people found for the selected tags.</li>';
                    // Ensure select all is disabled if no people
                    selectAllPeopleCheckbox.disabled = true; 
                    return;
                }

                // The selectAllPeopleCheckbox should always be enabled if there are people
                selectAllPeopleCheckbox.disabled = false;

                people.forEach(person => {
                    const li = document.createElement('li');
                    li.classList.add('person-item'); // Add a class for potential styling

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `person-checkbox-${person.id}`;
                    checkbox.value = person.id; // Store person ID in value
                    
                    const phoneNumber = getMobilePhoneNumber(person);
                    checkbox.dataset.phoneNumber = phoneNumber; // Store phone number in dataset

                    let labelText = `${person.first_name || ''} ${person.last_name || ''}`.trim();

                    if (phoneNumber === 'N/A') {
                        checkbox.disabled = true; // Disable checkbox if no mobile number
                        labelText += ' (No Mobile Number)';
                    } else {
                        labelText += ` (${phoneNumber})`;
                    }

                    // Add event listener for selecting people for SMS
                    checkbox.addEventListener('change', (event) => {
                        const personId = event.target.value;
                        const number = event.target.dataset.phoneNumber;
                        if (event.target.checked) {
                            selectedPeopleForSms.set(personId, number);
                        } else {
                            selectedPeopleForSms.delete(personId);
                        }
                        // Update selectAllPeopleCheckbox state
                        updateSelectAllCheckboxState(); 
                    });

                    const label = document.createElement('label');
                    label.htmlFor = `person-checkbox-${person.id}`;
                    label.textContent = labelText;

                    li.appendChild(checkbox);
                    li.appendChild(label);
                    peopleList.appendChild(li);
                });

                // Ensure initial state of selectAllPeopleCheckbox is correct
                updateSelectAllCheckboxState(); 
            }

            /**
             * Updates the state of the "Select All" checkbox based on individual checkboxes.
             */
            function updateSelectAllCheckboxState() { 
                // Only consider checkboxes that are not disabled
                const visibleEnabledCheckboxes = Array.from(peopleList.querySelectorAll('input[type="checkbox"]:not([disabled])'));
                const checkedEnabledCheckboxes = Array.from(peopleList.querySelectorAll('input[type="checkbox"]:checked:not([disabled])'));

                if (visibleEnabledCheckboxes.length > 0 && visibleEnabledCheckboxes.length === checkedEnabledCheckboxes.length) {
                    selectAllPeopleCheckbox.checked = true;
                } else {
                    selectAllPeopleCheckbox.checked = false;
                }
            }


            /**
             * Recursively renders the tag tree (folders and tags) into the DOM.
             * This function must be defined BEFORE fetchTagsAndRender.
             * @param {Array<Object>} nodes - An array of folder or tag nodes.
             * @param {HTMLElement} parentElement - The DOM element to append nodes to.
             */
            function renderTagTree(nodes, parentElement) {
                nodes.forEach(node => {
                    const itemDiv = document.createElement('div');
                    itemDiv.classList.add('tag-item');
                    itemDiv.style.marginLeft = `${node.type === 'tag' ? 20 : 0}px`; 

                    if (node.type === 'folder') {
                        const folderHeader = document.createElement('div');
                        folderHeader.classList.add('folder-header');
                        
                        const toggleIcon = document.createElement('span');
                        toggleIcon.classList.add('toggle-icon');
                        toggleIcon.innerHTML = node.expanded ? '&#9660;' : '&#9658;';
                        folderHeader.appendChild(toggleIcon);

                        const folderCheckbox = document.createElement('input');
                        folderCheckbox.type = 'checkbox';
                        folderCheckbox.id = `checkbox-${node.id}`;
                        folderCheckbox.dataset.id = node.id;
                        folderCheckbox.dataset.type = 'folder';
                        folderCheckbox.checked = node.checked;
                        folderHeader.appendChild(folderCheckbox);

                        const folderLabel = document.createElement('label');
                        folderLabel.htmlFor = `checkbox-${node.id}`;
                        folderLabel.textContent = node.name;
                        folderHeader.appendChild(folderLabel);
                        
                        itemDiv.appendChild(folderHeader);

                        const childrenContainer = document.createElement('div');
                        childrenContainer.classList.add('folder-children');
                        if (!node.expanded) {
                            childrenContainer.style.display = 'none';
                        }
                        
                        if (node.children && node.children.length > 0) {
                            renderTagTree(node.children, childrenContainer);
                        }
                        if (node.tags && node.tags.length > 0) {
                            node.tags.forEach(tag => {
                                const tagDiv = document.createElement('div');
                                tagDiv.classList.add('tag-item');
                                tagDiv.style.marginLeft = '20px';

                                const tagCheckbox = document.createElement('input');
                                tagCheckbox.type = 'checkbox';
                                tagCheckbox.id = `checkbox-${tag.id}`;
                                tagCheckbox.dataset.id = tag.id;
                                tagCheckbox.dataset.type = 'tag';
                                tagDiv.appendChild(tagCheckbox);

                                const tagLabel = document.createElement('label');
                                tagLabel.htmlFor = `checkbox-${tag.id}`;
                                tagLabel.textContent = tag.name;
                                tagDiv.appendChild(tagLabel);

                                childrenContainer.appendChild(tagDiv);

                                tagCheckbox.addEventListener('change', (event) => {
                                    updateTagCheckedState(tag.id, event.target.checked, 'tag');
                                });
                            });
                        }
                        itemDiv.appendChild(childrenContainer);

                        toggleIcon.addEventListener('click', () => {
                            node.expanded = !node.expanded;
                            childrenContainer.style.display = node.expanded ? 'block' : 'none';
                            toggleIcon.innerHTML = node.expanded ? '&#9660;' : '&#9658;';
                        });

                        folderCheckbox.addEventListener('change', (event) => {
                            updateTagCheckedState(node.id, event.target.checked, 'folder');
                            checkAllChildren(node, event.target.checked);
                        });

                    } else if (node.type === 'tag') {
                        const tagCheckbox = document.createElement('input');
                        tagCheckbox.type = 'checkbox';
                        tagCheckbox.id = `checkbox-${node.id}`;
                        tagCheckbox.dataset.id = node.id;
                        tagCheckbox.dataset.type = 'tag';
                        tagCheckbox.checked = node.checked;
                        itemDiv.appendChild(tagCheckbox);

                        const tagLabel = document.createElement('label');
                        tagLabel.htmlFor = `checkbox-${node.id}`;
                        tagLabel.textContent = node.name;
                        itemDiv.appendChild(tagLabel);

                        tagCheckbox.addEventListener('change', (event) => {
                            updateTagCheckedState(tag.id, event.target.checked, 'tag');
                        });
                    }
                    parentElement.appendChild(itemDiv);
                });
            }

            /**
             * Fetches people from the API, optionally filtered by selected tag IDs.
             * @param {Array<string>} selectedTagIds - An array of tag IDs to filter by.
             */
            async function fetchPeople(selectedTagIds = []) {
                try {
                    // Store the currently applied tag IDs
                    lastAppliedTagIds = selectedTagIds; 

                    if (selectedTagIds.length === 0) {
                        showMessageBox('No tags selected. Displaying all people.', 'info');
                        const response = await fetch('/api/people');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const people = await response.json();
                        displayPeople(people);
                        return;
                    }

                    const url = new URL('/api/people', window.location.origin); 
                    selectedTagIds.forEach(id => {
                        url.searchParams.append('tag_id', id);
                    });

                    const response = await fetch(url.toString());
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                        }
                    const people = await response.json();
                    displayPeople(people);
                } catch (error) {
                    console.error('Error fetching people:', error);
                    peopleList.innerHTML = `<li>Error loading people: ${error.message}</li>`;
                }
            }

            /**
             * Fetches structured tags and folders from the API and renders them.
             */
            async function fetchTagsAndRender() {
                tagLoadingIndicator.style.display = 'flex';
                tagContentWrapper.innerHTML = '';
                tagContentWrapper.style.display = 'none';

                try {
                    const response = await fetch('/api/tags');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    allTagsData = await response.json(); // THIS IS WHERE allTagsData IS POPULATED
                    renderTagTree(allTagsData, tagContentWrapper); // Calling renderTagTree
                    tagContentWrapper.style.display = 'block';
                } catch (error) {
                    console.error('Error fetching tags:', error);
                    tagContentWrapper.innerHTML = '<p style="color: red;">Error loading tags.</p>';
                    tagContentWrapper.style.display = 'block';
                } finally {
                    tagLoadingIndicator.style.display = 'none';
                }
            }


            // --- INITIAL CALLS AND EVENT LISTENERS ---
            fetchTagsAndRender(); // This is the initial call

            applyFilterButton.addEventListener('click', () => {
                const selectedTagIds = [];
                collectSelectedTagIds(allTagsData, selectedTagIds);
                fetchPeople(selectedTagIds);
            });

            // "Select All" checkbox event listener
            selectAllPeopleCheckbox.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                // Only select/deselect checkboxes that are NOT disabled
                const checkboxes = peopleList.querySelectorAll('input[type="checkbox"]:not([disabled])');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = isChecked;
                    // Manually trigger change event to update selectedPeopleForSms map
                    const changeEvent = new Event('change');
                    checkbox.dispatchEvent(changeEvent);
                });
            });


            sendSmsButton.addEventListener('click', async () => {
                // Get phone numbers directly from the selectedPeopleForSms map
                const phoneNumbersToSend = Array.from(selectedPeopleForSms.values()).filter(num => num !== 'N/A');
                const message = document.getElementById('message').value;

                if (phoneNumbersToSend.length === 0) {
                    showMessageBox('Please select at least one person with a valid phone number to send an SMS.', 'error');
                    return;
                }
                if (!message) {
                    showMessageBox('Please enter a message to send.', 'error');
                    return;
                }

                try {
                    // Join numbers with a comma for the 'to' field in the backend
                    const response = await fetch('/api/send-sms', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ to: phoneNumbersToSend.join(','), message: message })
                    });

                    const data = await response.json();
                    if (response.ok) {
                        showMessageBox('SMS sent successfully!', 'success');
                        // Clear message input
                        document.getElementById('message').value = ''; 
                        // Re-fetch people using the last applied filter to refresh the list
                        // This will also clear the checkboxes as displayPeople clears selectedPeopleForSms
                        fetchPeople(lastAppliedTagIds); 
                    } else {
                        showMessageBox(`Failed to send SMS: ${data.message}`, 'error');
                    }
                } catch (error) {
                    console.error('Error sending SMS:', error);
                    showMessageBox('Error sending SMS.', 'error');
                }
            });
        });
    </script>
</body>
</html>
