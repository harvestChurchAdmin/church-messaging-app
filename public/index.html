<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harvest Church Messenger</title>
    <!-- Google Fonts for consistency with login page -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/style.css"> <!-- Link to the shared stylesheet -->
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body class="app-body">
    <!-- Header for Logo and User Info -->
    <header class="app-header">
        <img id="appLogo" src="{{APP_LOGO_URL}}" alt="Application Logo" class="logo">
        <div class="user-info-container">
            <h2 id="userNameDisplay" class="user-info"></h2>
            <h3 id="userEmailDisplay" class="user-info"></h3>
            <button id="logoutButton" class="logout-button">Logout</button>
        </div>
    </header>

    <div class="container">
        <div class="left-column">
            <!-- SMS Message Section -->
            <div class="card sms-message-section">
                <h1>Send SMS Message</h1>
                <textarea id="message" placeholder="Enter your message" maxlength="160"></textarea>
                <div id="charCount" class="char-count">160 characters remaining</div>
                <button id="sendSms">Send SMS</button>
            </div>

            <!-- People List Section -->
            <div class="card people-list-section">
                <h2>Filtered People</h2>
                <!-- NEW: Search input for people list -->
                <input type="text" id="peopleSearchInput" placeholder="Search by name..." class="text-input" style="margin-bottom: 15px;">
                <div class="selection-controls" style="display: none;">
                    <button id="selectAllVisible">Select All Visible</button>
                    <button id="clearAllSelected">Clear All</button>
                </div>
                <div id="peopleList" class="people-list">
                    <p>Apply a tag filter to see people.</p>
                </div>
                <div id="peopleLoadingIndicator" class="loading-indicator" style="display: none;">
                    <div class="spinner"></div>
                    Loading people...
                </div>
            </div>

            <!-- SMS History Section -->
            <div class="card sms-history-section">
                <h1>SMS History</h1>
                <div class="sms-history-controls">
                    <button id="refreshSmsHistory">Refresh History</button>
                </div>
                <div class="sms-history-container">
                    <table id="smsHistoryTable">
                        <thead>
                            <tr>
                                <th>Recipient</th>
                                <th>Sender</th>
                                <th>Message</th>
                                <th>Status</th>
                                <th>Sent At</th>
                                <th>Last Update</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td colspan="6">Loading SMS history...</td></tr>
                        </tbody>
                    </table>
                    <div id="smsHistoryLoading" class="loading-indicator" style="display: none;">
                        <div class="spinner"></div>
                        Loading SMS history...
                    </div>
                </div>
            </div>
        </div>

        <div class="right-column">
            <!-- Tag Filter Section -->
            <div class="card tag-filter-section">
                <h1>Filter People by Tags</h1>
                <!-- Moved tagLoadingIndicator inside tagFilter, but before tag-content-wrapper -->
                <div id="tagFilter">
                    <div id="tagLoadingIndicator" class="loading-indicator">
                        <div class="spinner"></div>
                        Loading tags...
                    </div>
                    <!-- This div will now be the scrollable container for tags -->
                    <div class="tag-content-wrapper" style="display: none;"></div>
                </div>
                <!-- Button and cooldown display are now outside the scrollable tag-filter-container -->
                <button id="applyFilterButton">Apply Tag Filter</button>
                <div id="apiCooldownWrapper" style="margin-top: 10px; display: flex; flex-direction: column; align-items: center;">
                    <span id="apiCooldownDisplay" style="color: #d9534f; font-weight: bold;"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Message box for user feedback -->
    <div id="messageBox" class="message-box"></div>

    <script>
        // Store selected people's IDs and their full data for SMS sending
        let selectedPeopleForSms = new Map(); // Map: personId -> personObject (including phone number and name)
        let lastAppliedTagIds = []; // Stores the last set of tag IDs used for filtering people

        // Global variable to store logged-in user's details
        let currentUser = null;

        // Store all people fetched after a tag filter (for search within)
        let peopleFilteredByTags = [];

        // API Cooldown variables
        let isApiCoolingDown = false;
        let apiCooldownEndTime = 0;
        let apiCooldownInterval = null; // To store the setInterval ID

        document.addEventListener('DOMContentLoaded', async () => {
            const sendSmsButton = document.getElementById('sendSms');
            const messageInput = document.getElementById('message');
            const charCountDisplay = document.getElementById('charCount'); // Get character count element
            const peopleListDiv = document.getElementById('peopleList');
            const tagFilterDiv = document.getElementById('tagFilter'); // This is now just the container for tags and loading indicator
            const applyFilterButton = document.getElementById('applyFilterButton');
            const clearAllSelectedButton = document.getElementById('clearAllSelected');
            const selectAllVisibleButton = document.getElementById('selectAllVisible');
            const smsHistoryTableBody = document.querySelector('#smsHistoryTable tbody');
            const refreshSmsHistoryButton = document.getElementById('refreshSmsHistory');
            const tagLoadingIndicator = document.getElementById('tagLoadingIndicator');
            const tagContentWrapper = document.querySelector('#tagFilter .tag-content-wrapper'); // Adjusted selector
            const peopleLoadingIndicator = document.getElementById('peopleLoadingIndicator');
            const selectionControls = document.querySelector('.selection-controls');
            const smsHistoryLoading = document.getElementById('smsHistoryLoading');
            const peopleSearchInput = document.getElementById('peopleSearchInput'); // Get search input
            const apiCooldownDisplay = document.getElementById('apiCooldownDisplay'); // Get cooldown display element

            const MAX_SMS_CHARS = 160; // Define the maximum characters for a single SMS segment

            // Function to display messages to the user
            function showMessageBox(message, type = 'info', duration = 3000) {
                const messageBox = document.getElementById('messageBox');
                messageBox.textContent = message;
                messageBox.className = `message-box ${type} show`;

                setTimeout(() => {
                    messageBox.classList.remove('show');
                }, duration);
            }

            // Function to fetch the logged-in user's details
            async function fetchCurrentUser() {
                try {
                    const response = await fetch('/user'); 
                    if (!response.ok) {
                        if (response.status === 401 || response.status === 403) {
                            window.location.href = '/login';
                            return; 
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    currentUser = await response.json();
                    if (currentUser && currentUser.displayName && currentUser.email) {
                        document.getElementById('userNameDisplay').textContent = `Welcome, ${currentUser.displayName}`;
                        document.getElementById('userEmailDisplay').textContent = currentUser.email;
                    } else {
                        console.warn('Current user data is incomplete or not available.');
                        document.getElementById('userNameDisplay').textContent = 'Welcome!';
                        document.getElementById('userEmailDisplay').textContent = 'Email not found.';
                    }
                } catch (error) {
                    console.error('Error fetching current user:', error);
                    showMessageBox('Failed to fetch user data. Please refresh.', 'error');
                    // Do NOT redirect here for general errors, only for 401/403 handled above.
                    // This allows other parts of the page to load if possible.
                }
            }
            // fetchCurrentUser(); // No longer called directly here

            // Logout functionality
            const logoutButton = document.getElementById('logoutButton');
            if (logoutButton) {
                logoutButton.addEventListener('click', async () => {
                    try {
                        const response = await fetch('/auth/logout');
                        if (response.ok) {
                            window.location.href = '/login'; // Redirect to login page after successful logout
                        } else {
                            showMessageBox('Logout failed.', 'error');
                        }
                    } catch (error) {
                        console.error('Error during logout:', error);
                        showMessageBox('Error during logout.', 'error');
                    }
                });
            }

            // Helper function to format timestamps
            function formatTimestamp(timestamp) {
                if (!timestamp) return 'N/A';
                const date = new Date(timestamp);
                const options = {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true
                };
                return date.toLocaleString('en-US', options);
            }

            // Function to fetch SMS history
            async function fetchSmsHistory() {
                smsHistoryTableBody.innerHTML = '<tr><td colspan="6"></td></tr>';
                smsHistoryLoading.style.display = 'flex';

                try {
                    const response = await fetch('/api/sms-history');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const history = await response.json();
                    displaySmsHistory(history);
                } catch (error) {
                    console.error('Error fetching SMS history:', error);
                    showMessageBox('Failed to load SMS history.', 'error');
                    smsHistoryTableBody.innerHTML = '<tr><td colspan="6" class="error">Failed to load SMS history.</td></tr>';
                } finally {
                    smsHistoryLoading.style.display = 'none';
                }
            }
            // fetchSmsHistory(); // No longer called directly here

            // Function to display SMS history
            function displaySmsHistory(history) {
                smsHistoryTableBody.innerHTML = '';
                if (history.length === 0) {
                    smsHistoryTableBody.innerHTML = '<tr><td colspan="6">No SMS records found.</td></tr>';
                    return;
                }

                history.forEach(record => {
                    const row = smsHistoryTableBody.insertRow();
                    row.insertCell().textContent = record.recipientName || record.toPhoneNumber;
                    row.insertCell().textContent = record.senderName || record.senderUserId;
                    row.insertCell().textContent = record.messageBody;
                    row.insertCell().textContent = record.status;
                    row.insertCell().textContent = formatTimestamp(record.createdAt);
                    row.insertCell().textContent = formatTimestamp(record.updatedAt);

                    if (record.status === 'delivered') {
                        row.classList.add('status-delivered');
                    } else if (record.status === 'failed' || record.status === 'undelivered') {
                        row.classList.add('status-failed');
                    } else if (record.status === 'queued' || record.status === 'sending' || record.status === 'sent') {
                        row.classList.add('status-pending');
                    }
                });
            }

            // --- People List and Tag Filtering Functions ---

            let allPeopleFromTags = []; // Stores all people fetched from the *last applied tag filter*

            function getPhoneNumber(person) {
                const phoneEntries = person.details && person.details['1413026988'];
                if (Array.isArray(phoneEntries)) {
                    const mobileEntry = phoneEntries.find(entry => 
                        entry && entry.phone_type === 'mobile' && entry.phone_number
                    );
                    if (mobileEntry) {
                        return mobileEntry.phone_number;
                    }
                    if (phoneEntries.length > 0 && phoneEntries[0].phone_number) {
                        return phoneEntries[0].phone_number;
                    }
                }
                return null;
            }

            // Function to render the people list (can be all, or filtered by search)
            function renderPeopleList(peopleToDisplay) {
                peopleListDiv.innerHTML = '';
                // Do NOT clear selectedPeopleForSms here. It should persist across search filters.

                if (peopleToDisplay.length === 0) {
                    peopleListDiv.innerHTML = '<p>No people match your search or tag filter.</p>';
                    selectionControls.style.display = 'none';
                    return;
                }

                selectionControls.style.display = 'flex';

                peopleToDisplay.forEach(person => {
                    const personDiv = document.createElement('div');
                    personDiv.className = 'person-item';
                    const fullName = `${person.first_name || ''} ${person.last_name || ''}`.trim();
                    const phoneNumber = getPhoneNumber(person);

                    // Check if this person was already selected
                    const isSelected = selectedPeopleForSms.has(person.id);

                    personDiv.innerHTML = `
                        <input type="checkbox" id="person-${person.id}" value="${person.id}" ${phoneNumber ? '' : 'disabled'} ${isSelected ? 'checked' : ''}>
                        <label for="person-${person.id}">${fullName} ${phoneNumber ? `(${phoneNumber})` : ' (No Mobile Number)'}</label>
                    `;

                    // FIX: Changed quotes to backticks to resolve SyntaxError
                    const checkbox = personDiv.querySelector(`input[type="checkbox"]`);
                    if (!checkbox.disabled) {
                        checkbox.addEventListener('change', (event) => {
                            if (event.target.checked) {
                                selectedPeopleForSms.set(person.id, {
                                    id: person.id,
                                    name: fullName,
                                    phoneNumber: phoneNumber
                                });
                            } else {
                                selectedPeopleForSms.delete(person.id);
                            }
                        });
                    }
                    peopleListDiv.appendChild(personDiv);
                });
            }

            // Function to update the initial list after tag filtering
            function displayPeople(people) {
                allPeopleFromTags = people; // Store the full list from tag filter
                // Now, re-apply the search filter if there's a search term
                filterPeopleBySearchTerm(); // Will call renderPeopleList internally
            }


            // Function to filter people by search input
            function filterPeopleBySearchTerm() {
                const searchTerm = peopleSearchInput.value.toLowerCase().trim();
                let peopleToDisplay = allPeopleFromTags;

                if (searchTerm) {
                    peopleToDisplay = allPeopleFromTags.filter(person => {
                        const fullName = `${person.first_name || ''} ${person.last_name || ''}`.trim().toLowerCase();
                        const phoneNumber = getPhoneNumber(person); // Get phone number for search if needed
                        return fullName.includes(searchTerm) || (phoneNumber && phoneNumber.includes(searchTerm));
                    });
                }
                renderPeopleList(peopleToDisplay);
            }


            // Function to start the API cooldown timer
            function startApiCooldown(options = {}) {
                const {
                    baseDurationMs = 5000, // Default to 5 seconds for a successful call
                    errorDurationMs = 30000, // Longer for a 429 error
                    message = 'Waiting for server',
                    isError = false, // Flag to indicate if this cooldown is due to an error
                    peopleCount = 0 // Number of people returned, for dynamic adjustment
                } = options;

                let durationMs = isError ? errorDurationMs : baseDurationMs;

                // Adjust duration based on peopleCount if it's a successful call (not an error cooldown)
                if (!isError && peopleCount > 0) {
                    const COOLDOWN_PER_PERSON_MS = 100; // 100ms per person
                    const MIN_COOLDOWN_FOR_PEOPLE = 5000; // Minimum 5s if people are returned
                    let calculatedDynamicDuration = peopleCount * COOLDOWN_PER_PERSON_MS;

                    // The duration should be at least MIN_COOLDOWN_FOR_PEOPLE and also at least the calculated dynamic duration.
                    durationMs = Math.max(MIN_COOLDOWN_FOR_PEOPLE, calculatedDynamicDuration);
                } else if (!isError && peopleCount === 0) {
                    // If no people are returned for a successful (non-error) call, use a shorter default base cooldown
                    durationMs = 5000; // 5 seconds
                }

                // Cap the cooldown to a reasonable maximum if it gets too long
                const MAX_DYNAMIC_COOLDOWN = 90000; // Max 90 seconds
                durationMs = Math.min(durationMs, MAX_DYNAMIC_COOLDOWN);


                if (apiCooldownInterval) {
                    clearInterval(apiCooldownInterval);
                }
                isApiCoolingDown = true;
                applyFilterButton.disabled = true;
                applyFilterButton.style.opacity = '0.7'; // Visual hint
                applyFilterButton.style.cursor = 'not-allowed'; // Set cursor to not-allowed
                apiCooldownEndTime = Date.now() + durationMs;

                // Initial display of the message with the calculated full duration
                apiCooldownDisplay.textContent = `${message} (${Math.ceil(durationMs / 1000)}s)...`;

                apiCooldownInterval = setInterval(() => {
                    const timeLeft = Math.ceil((apiCooldownEndTime - Date.now()) / 1000);
                    if (timeLeft <= 0) {
                        clearInterval(apiCooldownInterval);
                        isApiCoolingDown = false;
                        applyFilterButton.disabled = false;
                        applyFilterButton.style.opacity = '1';
                        applyFilterButton.style.cursor = 'pointer'; // Reset cursor to pointer
                        apiCooldownDisplay.textContent = '';
                        showMessageBox('Server is ready. You can filter again.', 'info', 2000); // Updated message
                    } else {
                        apiCooldownDisplay.textContent = `${message} (${timeLeft}s)...`; // Updated message
                    }
                }, 1000); // Update every second
            }


            async function fetchPeople(tagIds = []) {
                if (isApiCoolingDown) {
                    showMessageBox(`API is currently on cooldown. Please wait before filtering again.`, 'warning');
                    return;
                }

                peopleListDiv.innerHTML = '<p>Loading people...</p>';
                peopleLoadingIndicator.style.display = 'flex';
                selectionControls.style.display = 'none';
                peopleSearchInput.value = ''; // Clear search input on new tag filter
                allPeopleFromTags = []; // Clear previous people data

                // Immediately disable button visually while loading (before API call)
                applyFilterButton.disabled = true;
                applyFilterButton.style.opacity = '0.7';
                applyFilterButton.style.cursor = 'not-allowed'; // Set cursor to not-allowed

                try {
                    const queryParams = tagIds.length > 0 ? `?${tagIds.map(id => `tag_id=${id}`).join('&')}` : '';
                    const response = await fetch(`/api/people${queryParams}`);
                    if (!response.ok) {
                        // Handle 429 Too Many Requests specifically
                        if (response.status === 429) {
                            console.error('Breeze API Rate Limit Exceeded (429)');
                            showMessageBox('Too many requests to Breeze API. Please wait a moment.', 'error', 5000);
                            startApiCooldown({
                                errorDurationMs: 30000, // Increased error cooldown
                                message: 'Rate limit hit. Waiting for server',
                                isError: true
                            }); // Longer cooldown for actual 429
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const people = await response.json();
                    displayPeople(people); // This now populates allPeopleFromTags and triggers search filter
                    lastAppliedTagIds = tagIds;
                    startApiCooldown({
                        peopleCount: people.length,
                        message: 'Processing complete. Waiting',
                        baseDurationMs: 5000 // Ensure base duration is passed for successful calls
                    }); // Start cooldown after a successful request, with dynamic duration
                } catch (error) {
                    console.error('Error fetching people:', error);
                    peopleListDiv.innerHTML = '<p class="error">Failed to load people. Please try again.</p>';
                    selectionControls.style.display = 'none';
                    // Re-enable button if there was an error not leading to startApiCooldown (e.g. general HTTP error)
                    if (!isApiCoolingDown) { // Only re-enable if no cooldown was triggered by a 429
                       applyFilterButton.disabled = false;
                       applyFilterButton.style.opacity = '1';
                       applyFilterButton.style.cursor = 'pointer'; // Reset cursor to pointer
                    }
                } finally {
                    peopleLoadingIndicator.style.display = 'none';
                }
            }

            /**
             * Recursively sets the checked state for a node (folder or tag) and its children.
             * @param {object} node - The tag or folder node.
             * @param {boolean} checked - The desired checked state.
             */
            function setNodeCheckedState(node, checked) {
                node.checked = checked; // Set the current node's checked state
                
                // Update the DOM checkbox for the current node (folder or tag)
                const selfCheckbox = document.getElementById(`${node.type}-${node.id}`);
                if (selfCheckbox) {
                    selfCheckbox.checked = checked;
                }

                // If it's a folder, iterate through its tags and children
                if (node.type === 'folder') {
                    // Update immediate child tags
                    if (node.tags) {
                        node.tags.forEach(tag => {
                            tag.checked = checked;
                            // Also update the actual checkbox in the DOM if it exists
                            const checkbox = document.getElementById(`tag-${tag.id}`);
                            if (checkbox) checkbox.checked = checked;
                        });
                    }
                    // Recursively update child folders
                    if (node.children) {
                        node.children.forEach(childNode => setNodeCheckedState(childNode, checked));
                    }
                } 
            }


            // Function to display nested tags and folders
            function displayTags(tagTree, parentElement) {
                tagContentWrapper.innerHTML = '';
                tagContentWrapper.style.display = 'block';

                tagTree.forEach(node => {
                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = `tag-node ${node.type}`;

                    if (node.type === 'folder') {
                        const folderHeader = document.createElement('div');
                        folderHeader.className = 'folder-header';
                        // Added checkbox for the folder itself
                        folderHeader.innerHTML = `
                            <span class="folder-toggle ${node.expanded ? 'expanded' : ''}">▶</span>
                            <input type="checkbox" id="folder-${node.id}" value="${node.id}" ${node.checked ? 'checked' : ''}>
                            <label for="folder-${node.id}"> ${node.name}</label>
                        `;
                        nodeDiv.appendChild(folderHeader);

                        const childrenContainer = document.createElement('div');
                        childrenContainer.className = 'folder-children';
                        if (node.expanded) {
                            childrenContainer.style.display = 'block';
                        } else {
                            childrenContainer.style.display = 'none';
                        }
                        nodeDiv.appendChild(childrenContainer);

                        // Event listener for the folder toggle icon
                        folderHeader.querySelector('.folder-toggle').addEventListener('click', () => {
                            node.expanded = !node.expanded;
                            folderHeader.querySelector('.folder-toggle').classList.toggle('expanded', node.expanded);
                            childrenContainer.style.display = node.expanded ? 'block' : 'none';
                        });

                        // Event listener for the folder checkbox
                        folderHeader.querySelector(`input[type="checkbox"]#folder-${node.id}`).addEventListener('change', (event) => {
                            setNodeCheckedState(node, event.target.checked);
                        });

                        node.tags.forEach(tag => {
                            const tagItemDiv = document.createElement('div');
                            tagItemDiv.className = 'tag-item';
                            tagItemDiv.innerHTML = `
                                <input type="checkbox" id="tag-${tag.id}" value="${tag.id}" ${tag.checked ? 'checked' : ''}>
                                <label for="tag-${tag.id}">${tag.name}</label>
                            `;
                            childrenContainer.appendChild(tagItemDiv);

                            tagItemDiv.querySelector('input[type="checkbox"]').addEventListener('change', () => {
                                tag.checked = !tag.checked;
                            });
                        });

                        if (node.children && node.children.length > 0) {
                            displayTags(node.children, childrenContainer);
                        }
                    } else if (node.type === 'tag') {
                        const tagItemDiv = document.createElement('div');
                        tagItemDiv.className = 'tag-item';
                        tagItemDiv.innerHTML = `
                            <input type="checkbox" id="tag-${node.id}" value="${node.id}" ${node.checked ? 'checked' : ''}>
                            <label for="tag-${node.id}">${node.name}</label>
                        `;
                        nodeDiv.appendChild(tagItemDiv);

                        tagItemDiv.querySelector('input[type="checkbox"]').addEventListener('change', () => {
                            node.checked = !node.checked;
                        });
                    }
                    parentElement.appendChild(nodeDiv);
                });
            }

            let currentTagTree = [];
            async function fetchTags() {
                tagLoadingIndicator.style.display = 'flex';
                tagContentWrapper.style.display = 'none';

                try {
                    const response = await fetch('/api/tags');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    currentTagTree = await response.json();
                    displayTags(currentTagTree, tagContentWrapper);
                } catch (error) {
                    console.error('Error fetching tags:', error);
                    tagContentWrapper.innerHTML = '<p class="error">Failed to load tags. Please try again.</p>';
                    tagContentWrapper.style.display = 'block';
                } finally {
                    tagLoadingIndicator.style.display = 'none';
                }
            }
            // fetchTags(); // No longer called directly here

            /**
             * Recursively collects all checked tag IDs from the tag tree.
             * Includes tags directly checked and tags within checked folders.
             * @param {Array<object>} nodes - The array of tag/folder nodes.
             * @returns {Array<string>} An array of checked tag IDs.
             */
            function getCheckedTagIds(nodes) {
                let checkedIds = [];
                nodes.forEach(node => {
                    if (node.type === 'tag' && node.checked) {
                        checkedIds.push(node.id);
                    } else if (node.type === 'folder' && node.checked) {
                        // If the folder itself is checked, add all its contained tags
                        if (node.tags) {
                            node.tags.forEach(tag => checkedIds.push(tag.id));
                        }
                        // And recursively add tags from its children (subfolders)
                        if (node.children) {
                            checkedIds = checkedIds.concat(getCheckedTagIds(node.children));
                        }
                    } else if (node.type === 'folder' && !node.checked) {
                        // If folder is not checked, still check its direct children for individual checks
                        if (node.tags) {
                            node.tags.forEach(tag => {
                                if (tag.checked) checkedIds.push(tag.id);
                            });
                        }
                        // And recursively check subfolders' individually checked tags
                        if (node.children) {
                            checkedIds = checkedIds.concat(getCheckedTagIds(node.children));
                        }
                    }
                });
                // Ensure unique IDs in case a tag is duplicated or within multiple selected paths
                return [...new Set(checkedIds)];
            }

            // Debounce utility function
            function debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            function updatePeopleFilter() {
                if (isApiCoolingDown) {
                    showMessageBox(`Please wait ${Math.ceil((apiCooldownEndTime - Date.now()) / 1000)}s before applying another filter.`, 'warning');
                    return;
                }

                const checkedTagIds = getCheckedTagIds(currentTagTree);
                if (checkedTagIds.length === 0) {
                    peopleListDiv.innerHTML = '<p>No tags selected. Apply a tag filter to see people.</p>';
                    selectionControls.style.display = 'none';
                    allPeopleFromTags = []; // Clear people when no tags selected
                    peopleSearchInput.value = ''; // Clear search input
                    return;
                }
                fetchPeople(checkedTagIds);
            }

            // "Clear All" button functionality
            clearAllSelectedButton.addEventListener('click', () => {
                selectedPeopleForSms.clear();
                document.querySelectorAll('#peopleList input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
            });

            // "Select All Visible" button functionality
            selectAllVisibleButton.addEventListener('click', () => {
                // Selects only the currently RENDERED people
                document.querySelectorAll('#peopleList .person-item input[type="checkbox"]').forEach(checkbox => {
                    const personId = checkbox.value;
                    // Find the person object from the *originally filtered by tags* list
                    const person = allPeopleFromTags.find(p => p.id === personId);
                    const phoneNumber = getPhoneNumber(person);

                    if (phoneNumber) {
                        checkbox.checked = true;
                        const fullName = `${person.first_name || ''} ${person.last_name || ''}`.trim();
                        selectedPeopleForSms.set(person.id, {
                            id: person.id,
                            name: fullName,
                            phoneNumber: phoneNumber
                        });
                    } else {
                        checkbox.checked = false;
                    }
                });
            });

            // Send SMS button functionality
            sendSmsButton.addEventListener('click', async () => {
                const message = messageInput.value.trim();
                const peopleToSend = Array.from(selectedPeopleForSms.values());

                if (peopleToSend.length === 0) {
                    showMessageBox('Please select at least one person to send an SMS.', 'error');
                    return;
                }

                if (!message) {
                    showMessageBox('Please enter a message to send.', 'error');
                    return;
                }

                if (!currentUser || !currentUser.displayName) {
                    showMessageBox('Sender information not available. Please log in again.', 'error');
                    return;
                }

                try {
                    for (const person of peopleToSend) {
                        const phoneNumber = person.phoneNumber;
                        const recipientName = person.name;
                        const senderName = currentUser.displayName;

                        const response = await fetch('/api/send-sms', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                to: phoneNumber,
                                message: message,
                                recipientName: recipientName,
                                senderName: senderName
                            })
                        });

                        const data = await response.json();
                        if (response.ok) {
                            showMessageBox(`SMS sent to ${recipientName} successfully!`, 'success');
                        } else {
                            showMessageBox(`Failed to send SMS to ${recipientName}: ${data.message}`, 'error');
                        }
                    }

                    document.getElementById('message').value = '';
                    selectedPeopleForSms.clear();
                    document.querySelectorAll('#peopleList input[type="checkbox"]').forEach(checkbox => {
                        checkbox.checked = false;
                    });
                    fetchSmsHistory(); // Refresh SMS history after sending
                } catch (error) {
                    console.error('Error sending SMS:', error);
                    showMessageBox('Error sending SMS to one or more recipients.', 'error');
                }
            });

            refreshSmsHistoryButton.addEventListener('click', fetchSmsHistory);
            // Apply debounce to the applyFilterButton click handler
            applyFilterButton.addEventListener('click', debounce(updatePeopleFilter, 500)); // Debounce by 500ms
            
            // Add event listener for the search input
            peopleSearchInput.addEventListener('input', filterPeopleBySearchTerm);


            // Update character count on input
            messageInput.addEventListener('input', () => {
                const charsRemaining = MAX_SMS_CHARS - messageInput.value.length;
                charCountDisplay.textContent = `${charsRemaining} characters remaining`;
                if (charsRemaining < 0) {
                    charCountDisplay.style.color = 'red';
                } else {
                    charCountDisplay.style.color = ''; // Reset to default
                }
            });

            // Initial character count display
            messageInput.dispatchEvent(new Event('input'));

            // Initial fetches on page load: Await these to ensure proper order and error handling
            try {
                await fetchCurrentUser();
                await fetchTags();
                await fetchSmsHistory();
            } catch (error) {
                console.error('Error during initial page load setup:', error);
                showMessageBox('An error occurred during initial setup. Please refresh the page.', 'error', 5000);
            }
        });
    </script>
</body>
</html>
